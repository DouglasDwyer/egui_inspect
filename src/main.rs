#![allow(warnings)]

#![feature(formatting_options)]

use std::{collections::*, env::var};
use rustdoc_types::*;

/// Defines the C# and Rust members that will be autogenerated.
mod ag;


pub struct BindgenContext {
    /// The definitions to create in C# and Rust.
    items: Vec<ag::Item>,
    krate: Crate,
    remaining_items: Vec<Id>,
    result: String,
    total_items: usize
}

impl BindgenContext {
    pub fn new() -> Self {
        let items = Vec::new();
        let krate = serde_json::from_str::<Crate>(include_str!("egui.json")).expect("Failed to parse egui");
        let mut remaining_items = krate.index.values().filter(Self::item_relevant).map(|x| x.id).collect::<Vec<_>>();
        let total_items = remaining_items.len();
        let result = String::new();

        Self {
            items,
            krate,
            remaining_items,
            total_items,
            result
        }
    }
    
    pub fn collect(&mut self) {
        self.collect_primitive_enums();
    }

    fn collect_primitive_enums(&mut self) {
        let mut remaining = self.remaining_items.clone();
        remaining.retain(|x| {
            let item = &self.krate.index[x];
            match &item.inner {
                ItemEnum::Enum(x) => !self.collect_primitive_enum(item.id),
                _ => true
            }
        });
        self.remaining_items = remaining;
    }
    
    fn collect_primitive_enum(&mut self, id: Id) -> bool {
        let ItemEnum::Enum(x) = &self.krate.index[&id].inner else { unreachable!() };
        if self.is_primitive_enum(x) {
            let enum_ty = &self.krate.index[&id];
            
            let variants = x.variants.iter().map(|id| {
                let variant = &self.krate.index[id];
                let ItemEnum::Variant(inner) = &variant.inner else { unreachable!() };
                
                ag::EnumVariant {
                    docs: variant.docs.clone().unwrap_or_default(),
                    name: variant.name.clone().unwrap_or_default(),
                    index: inner.discriminant.as_ref().map(|x| str::parse(&x.value).expect("Failed to parse enum discriminant"))
                }
            }).collect();

            self.items.push(ag::Item::Enum {
                docs: enum_ty.docs.clone().unwrap_or_default(),
                name: enum_ty.name.clone().unwrap_or_default(),
                variants
            });

            true
        }
        else {
            false
        }
    }
    
    /// Checks if the enum only has primitive variants.
    fn is_primitive_enum(&self, x: &Enum) -> bool {
        for variant in &x.variants {
            let ItemEnum::Variant(x) = &self.krate.index[variant].inner else { unreachable!() };
            if x.kind != VariantKind::Plain {
                return false;
            }
        }
    
        true
    }
    
    /// Whether this is an item for which we will generate code.
    fn item_relevant(x: &&Item) -> bool {
        match &x.inner {
            ItemEnum::Union(_)
            | ItemEnum::Struct(_)
            | ItemEnum::Enum(_)
            | ItemEnum::Function(_)
            | ItemEnum::TypeAlias(_)
            | ItemEnum::Constant { .. }
            | ItemEnum::Static(_)
            | ItemEnum::ExternType
            | ItemEnum::Macro(_)
            | ItemEnum::ProcMacro(_) => true,
            _ => false
        }
    }
    
    /*
    fn default_known_types() -> HashMap<String, KnownType> {
        [
            ("i32", KnownType::new("int", TypeKind::Copy)),
            ("u32", KnownType::new("uint", TypeKind::Copy)),
            ("f32", KnownType::new("float", TypeKind::Copy)),
            ("f64", KnownType::new("double", TypeKind::Copy)),
            ("egui::Pos2", KnownType::new("IVec2", TypeKind::Copy)),
            ("egui::Vec2", KnownType::new("IVec2", TypeKind::Copy)),
            ("egui::Vec2", KnownType::new("IVec2", TypeKind::Copy)),
        ].into_iter().map(|(a, b)| (a.to_owned(), b)).collect()
    } */
}

#[derive(Clone, Debug)]
struct KnownType {
    pub cs_name: String,
    pub kind: TypeKind
}

impl KnownType {
    pub fn new(cs_name: impl Into<String>, kind: TypeKind) -> Self {
        Self { cs_name: cs_name.into(), kind }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum TypeKind {
    Copy,
    Opaque
}

pub fn main() {
    let mut ctx = BindgenContext::new();
    ctx.collect();
    
    for item in &ctx.items {
        println!("{}", ag::DisplayRs(item));
    }

    println!("{} / {} items", ctx.total_items - ctx.remaining_items.len(), ctx.total_items);
}